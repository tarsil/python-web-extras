{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python Web Extras \u00b6 Official Documentation - https://tarsil.github.io/python-web-extras Table of Contents \u00b6 Python Web Extras Table of Contents About Python Web Extras Tortoise ORM Overview Supported Python Versions Installation License About Python Web Extras \u00b6 Python Web Extras is a miscellaneous of common utilities for FastAPI, Quart and future integrations with other frameworks. The aim is to make the life of developers simpler when it comes to some configurations. Python Web Extras also brings extra integrations with Tortoise ORM . Tortoise offers a way of integrating models into any application without a lot of configurations previously faced with others (SQLAlchemy, for instance) and for those familiar with Django , then Tortoise is a brise. Tortoise ORM \u00b6 When building an application that manages users, Django offers an out of the box built-in User models that can be very useful within the whole set of dependencies. Tortoise ORM is a bit less opinionated regarding those and therefore Python Web Extras offers a similar abstraction based Django where a create_user and create_super_user as well as password hashing are handled by simply inheriting from the base user model. Overview \u00b6 Supported Python Versions \u00b6 Python 3.8 3.9 3.10 Installation \u00b6 To install python-web-extras: pip install python-web-extras License \u00b6 Copyright (c) 2022-present Tiago Silva and contributors under the MIT license .","title":"Introduction"},{"location":"#python-web-extras","text":"Official Documentation - https://tarsil.github.io/python-web-extras","title":"Python Web Extras"},{"location":"#table-of-contents","text":"Python Web Extras Table of Contents About Python Web Extras Tortoise ORM Overview Supported Python Versions Installation License","title":"Table of Contents"},{"location":"#about-python-web-extras","text":"Python Web Extras is a miscellaneous of common utilities for FastAPI, Quart and future integrations with other frameworks. The aim is to make the life of developers simpler when it comes to some configurations. Python Web Extras also brings extra integrations with Tortoise ORM . Tortoise offers a way of integrating models into any application without a lot of configurations previously faced with others (SQLAlchemy, for instance) and for those familiar with Django , then Tortoise is a brise.","title":"About Python Web Extras"},{"location":"#tortoise-orm","text":"When building an application that manages users, Django offers an out of the box built-in User models that can be very useful within the whole set of dependencies. Tortoise ORM is a bit less opinionated regarding those and therefore Python Web Extras offers a similar abstraction based Django where a create_user and create_super_user as well as password hashing are handled by simply inheriting from the base user model.","title":"Tortoise ORM"},{"location":"#overview","text":"","title":"Overview"},{"location":"#supported-python-versions","text":"Python 3.8 3.9 3.10","title":"Supported Python Versions"},{"location":"#installation","text":"To install python-web-extras: pip install python-web-extras","title":"Installation"},{"location":"#license","text":"Copyright (c) 2022-present Tiago Silva and contributors under the MIT license .","title":"License"},{"location":"releases/","text":"Releases \u00b6 0.1.0 \u00b6 Initial release of python-web-extras .","title":"Releases"},{"location":"releases/#releases","text":"","title":"Releases"},{"location":"releases/#010","text":"Initial release of python-web-extras .","title":"0.1.0"},{"location":"roadmap/","text":"Roadmap \u00b6 Table of Contents \u00b6 Roadmap Table of Contents Integrations FastAPI Quart Sanic Starlette Integrations \u00b6 We intend to expand this package to support more frameworks. FastAPI \u00b6 Done. Cookiecutter using it Quart \u00b6 Coming soon Sanic \u00b6 Q4 of 2022/Q1 of 2023 Starlette \u00b6 Q4 of 2022/Q1 of 2023 Documentation \u00b6 Add more examples to the docs soon.","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"roadmap/#table-of-contents","text":"Roadmap Table of Contents Integrations FastAPI Quart Sanic Starlette","title":"Table of Contents"},{"location":"roadmap/#integrations","text":"We intend to expand this package to support more frameworks.","title":"Integrations"},{"location":"roadmap/#fastapi","text":"Done. Cookiecutter using it","title":"FastAPI"},{"location":"roadmap/#quart","text":"Coming soon","title":"Quart"},{"location":"roadmap/#sanic","text":"Q4 of 2022/Q1 of 2023","title":"Sanic"},{"location":"roadmap/#starlette","text":"Q4 of 2022/Q1 of 2023","title":"Starlette"},{"location":"roadmap/#documentation","text":"Add more examples to the docs soon.","title":"Documentation"},{"location":"fastapi/conf/","text":"Conf loader \u00b6 Python Web Extras is unique in it's simplicity of loading dynamic settings, one of the biggest hurdles of setting up enviroments and configurations of any project that consumes a lot of time. Table of Contents \u00b6 Conf loader Table of Contents Automated load conf settings Django settings module Dynamically loading Python Web Extras module Dynamically loading Example Dynamically loading Full working cookiecutter Automated load conf settings \u00b6 This package also provides a clean way to load your setting in a very django similar fashion. Example: # views.py python_web_extras . fastapi . conf import settings Although this is very simple, there is a lot going on here. Since these package was based on the simplicity of loading modules (coming from django) we decided to have a similar approach. Let's see: Django settings module \u00b6 Django by default has a DJANGO_SETTINGS_MODULE where the default is always the name of the project.settings generated, example myapp.settings . Dynamically loading \u00b6 Django allows to call the manage.py with different settings with two ways. Environment variable: DJANGO_SETTINGS_MODULE = 'myapp.development.settings' python manage.py runserver Settings property: python manage.py runserver --settings = 'myapp.development.settings' Python Web Extras module \u00b6 The approach is basically the same as django but we called it FASTAPI_SETTINGS_MODULE and it works exactly the same way when it comes to loading the settings module. Dynamically loading \u00b6 We prefer the loading of settings via environment variables as we believe it's cleaner. Example: # main.py # Load the settings from the module from fastapi import FastAPI python_web_extras . fastapi . conf import settings # the rest of the logic for the app app = FastAPI ( ** settings . fastapi_kwargs ) FASTAPI_SETTINGS_MODULE = 'core.development.settings' python app.py The above example is expecting the module location to be passed as a string into FASTAPI_SETTINGS_MODULE or else it will default to python_web_extras.fastapi.api_settings . Example \u00b6 An application structure, quite complex and similar to a production ready version. \u2514\u2500\u2500 src \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 apps \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 accounts \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 models.py \u2502 \u2514\u2500\u2500 v1 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 routes.py \u2502 \u2514\u2500\u2500 views.py \u251c\u2500\u2500 core \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 configs \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u251c\u2500\u2500 databases \u2502 \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u2502 \u251c\u2500\u2500 config.py \u2502 \u2502 \u2502 \u251c\u2500\u2500 routers.py \u2502 \u2502 \u2502 \u2514\u2500\u2500 settings.py \u2502 \u2502 \u251c\u2500\u2500 development \u2502 \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u2502 \u251c\u2500\u2500 local_settings.py \u2502 \u2502 \u2502 \u2514\u2500\u2500 settings.py \u2502 \u2502 \u251c\u2500\u2500 settings.py \u2502 \u2502 \u251c\u2500\u2500 testing \u2502 \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u2502 \u2514\u2500\u2500 settings.py \u2502 \u2502 \u2514\u2500\u2500 urls.py \u2514\u2500\u2500 main.py The application is split by responsabilities and all the settings live inside a core/configs module. core.configs.settings - App settings. core.configs.development.settings - Development settings. core.configs.testing.settings - Testing settings. Development and testing are inherited from the main settings and therefore there is no reason to replicate existing configurations and keep the codebase clean. Dynamically loading \u00b6 Using the example above we want to start the environments with the correct settings. main.py file # main.py # Load the settings from the module from fastapi import FastAPI python_web_extras . fastapi . conf import settings # the rest of the logic for the app app = FastAPI ( ** settings . fastapi_kwargs ) Start different environtments. FASTAPI_SETTINGS_MODULE = 'core.configs.development.settings' src.main # Starts the dev settings FASTAPI_SETTINGS_MODULE = 'core.configs.testing.settings' src.main # Starts the testing settings FASTAPI_SETTINGS_MODULE = 'core.configs.settings' src.main # Starts with main settings python_web_extras.fastapi.conf import settings will know which settings to load by reading the enviroment variable FASTAPI_SETTINGS_MODULE keeping the code clean and the configurations separated. Full working cookiecutter \u00b6 This package is being already used with a similar approach here . A cookiecutter already prepared and designed for business.","title":"Conf Loader"},{"location":"fastapi/conf/#conf-loader","text":"Python Web Extras is unique in it's simplicity of loading dynamic settings, one of the biggest hurdles of setting up enviroments and configurations of any project that consumes a lot of time.","title":"Conf loader"},{"location":"fastapi/conf/#table-of-contents","text":"Conf loader Table of Contents Automated load conf settings Django settings module Dynamically loading Python Web Extras module Dynamically loading Example Dynamically loading Full working cookiecutter","title":"Table of Contents"},{"location":"fastapi/conf/#automated-load-conf-settings","text":"This package also provides a clean way to load your setting in a very django similar fashion. Example: # views.py python_web_extras . fastapi . conf import settings Although this is very simple, there is a lot going on here. Since these package was based on the simplicity of loading modules (coming from django) we decided to have a similar approach. Let's see:","title":"Automated load conf settings"},{"location":"fastapi/conf/#django-settings-module","text":"Django by default has a DJANGO_SETTINGS_MODULE where the default is always the name of the project.settings generated, example myapp.settings .","title":"Django settings module"},{"location":"fastapi/conf/#dynamically-loading","text":"Django allows to call the manage.py with different settings with two ways. Environment variable: DJANGO_SETTINGS_MODULE = 'myapp.development.settings' python manage.py runserver Settings property: python manage.py runserver --settings = 'myapp.development.settings'","title":"Dynamically loading"},{"location":"fastapi/conf/#python-web-extras-module","text":"The approach is basically the same as django but we called it FASTAPI_SETTINGS_MODULE and it works exactly the same way when it comes to loading the settings module.","title":"Python Web Extras module"},{"location":"fastapi/conf/#dynamically-loading_1","text":"We prefer the loading of settings via environment variables as we believe it's cleaner. Example: # main.py # Load the settings from the module from fastapi import FastAPI python_web_extras . fastapi . conf import settings # the rest of the logic for the app app = FastAPI ( ** settings . fastapi_kwargs ) FASTAPI_SETTINGS_MODULE = 'core.development.settings' python app.py The above example is expecting the module location to be passed as a string into FASTAPI_SETTINGS_MODULE or else it will default to python_web_extras.fastapi.api_settings .","title":"Dynamically loading"},{"location":"fastapi/conf/#example","text":"An application structure, quite complex and similar to a production ready version. \u2514\u2500\u2500 src \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 apps \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 accounts \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 models.py \u2502 \u2514\u2500\u2500 v1 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 routes.py \u2502 \u2514\u2500\u2500 views.py \u251c\u2500\u2500 core \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 configs \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u251c\u2500\u2500 databases \u2502 \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u2502 \u251c\u2500\u2500 config.py \u2502 \u2502 \u2502 \u251c\u2500\u2500 routers.py \u2502 \u2502 \u2502 \u2514\u2500\u2500 settings.py \u2502 \u2502 \u251c\u2500\u2500 development \u2502 \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u2502 \u251c\u2500\u2500 local_settings.py \u2502 \u2502 \u2502 \u2514\u2500\u2500 settings.py \u2502 \u2502 \u251c\u2500\u2500 settings.py \u2502 \u2502 \u251c\u2500\u2500 testing \u2502 \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u2502 \u2514\u2500\u2500 settings.py \u2502 \u2502 \u2514\u2500\u2500 urls.py \u2514\u2500\u2500 main.py The application is split by responsabilities and all the settings live inside a core/configs module. core.configs.settings - App settings. core.configs.development.settings - Development settings. core.configs.testing.settings - Testing settings. Development and testing are inherited from the main settings and therefore there is no reason to replicate existing configurations and keep the codebase clean.","title":"Example"},{"location":"fastapi/conf/#dynamically-loading_2","text":"Using the example above we want to start the environments with the correct settings. main.py file # main.py # Load the settings from the module from fastapi import FastAPI python_web_extras . fastapi . conf import settings # the rest of the logic for the app app = FastAPI ( ** settings . fastapi_kwargs ) Start different environtments. FASTAPI_SETTINGS_MODULE = 'core.configs.development.settings' src.main # Starts the dev settings FASTAPI_SETTINGS_MODULE = 'core.configs.testing.settings' src.main # Starts the testing settings FASTAPI_SETTINGS_MODULE = 'core.configs.settings' src.main # Starts with main settings python_web_extras.fastapi.conf import settings will know which settings to load by reading the enviroment variable FASTAPI_SETTINGS_MODULE keeping the code clean and the configurations separated.","title":"Dynamically loading"},{"location":"fastapi/conf/#full-working-cookiecutter","text":"This package is being already used with a similar approach here . A cookiecutter already prepared and designed for business.","title":"Full working cookiecutter"},{"location":"fastapi/errors/","text":"Error Handling \u00b6 Handling errors in an application is another must. The errors can be added into the middleware of any FastAPI application. Table of Contents \u00b6 Error Handling Table of Contents http_error_handler http422_error_handler Working example http_error_handler \u00b6 Example: from fastapi.exceptions import RequestValidationError from starlette.exceptions import HTTPException from python_web_extras.fastapi.errors.http_error import http_error_handler app = FastAPI ( __name__ ) app . add_exception_handler ( HTTPException , http_error_handler ) http422_error_handler \u00b6 Example: from fastapi.exceptions import RequestValidationError from starlette.exceptions import HTTPException from python_web_extras.fastapi.errors.validation_error import http422_error_handler app = FastAPI ( __name__ ) app . add_exception_handler ( RequestValidationError , http422_error_handler ) Working example \u00b6 An example of this approach can be found here .","title":"Error Handing"},{"location":"fastapi/errors/#error-handling","text":"Handling errors in an application is another must. The errors can be added into the middleware of any FastAPI application.","title":"Error Handling"},{"location":"fastapi/errors/#table-of-contents","text":"Error Handling Table of Contents http_error_handler http422_error_handler Working example","title":"Table of Contents"},{"location":"fastapi/errors/#http_error_handler","text":"Example: from fastapi.exceptions import RequestValidationError from starlette.exceptions import HTTPException from python_web_extras.fastapi.errors.http_error import http_error_handler app = FastAPI ( __name__ ) app . add_exception_handler ( HTTPException , http_error_handler )","title":"http_error_handler"},{"location":"fastapi/errors/#http422_error_handler","text":"Example: from fastapi.exceptions import RequestValidationError from starlette.exceptions import HTTPException from python_web_extras.fastapi.errors.validation_error import http422_error_handler app = FastAPI ( __name__ ) app . add_exception_handler ( RequestValidationError , http422_error_handler )","title":"http422_error_handler"},{"location":"fastapi/errors/#working-example","text":"An example of this approach can be found here .","title":"Working example"},{"location":"fastapi/logging/","text":"Logging \u00b6 Logging an application is a must and not a nice to have and mostly due to the errors that constantly happen during development time. Table of Contents \u00b6 Logging Table of Contents InterceptHandler How to use it Working example InterceptHandler \u00b6 As mentioned before, if not, please check API Settings , Python Web Extras uses FastAPI Utilities under the hood and therefore uses some of it's practices, more precisely the get_settings() . How to use it \u00b6 To apply the interceptor, we recommend to add it into the base settings. Example: from loguru import logger from python_web_extras.fastapi.api_settings import APISettings from python_web_extras.fastapi.logging import InterceptHandler class Settings ( APISettings ): ... ... @lru_cache () def get_settings () -> Settings : settings = Settings () configure_logger ( settings ) return settings def configure_logger ( settings : Settings ) -> None : logging_level = logging . DEBUG if settings . debug else logging . INFO loggers = ( \"uvicorn.asgi\" , \"uvicorn.access\" ) logging . getLogger () . handlers = [ InterceptHandler ()] for logger_name in loggers : logging_logger = logging . getLogger ( logger_name ) logging_logger . handlers = [ InterceptHandler ( level = logging_level )] logger . configure ( handlers = [{ \"sink\" : sys . stderr , \"level\" : logging_level }]) From now on when the app starts with these settings, it will have the InterceptHandler embed and operational. Working example \u00b6 An example of this approach can be found here .","title":"Logging"},{"location":"fastapi/logging/#logging","text":"Logging an application is a must and not a nice to have and mostly due to the errors that constantly happen during development time.","title":"Logging"},{"location":"fastapi/logging/#table-of-contents","text":"Logging Table of Contents InterceptHandler How to use it Working example","title":"Table of Contents"},{"location":"fastapi/logging/#intercepthandler","text":"As mentioned before, if not, please check API Settings , Python Web Extras uses FastAPI Utilities under the hood and therefore uses some of it's practices, more precisely the get_settings() .","title":"InterceptHandler"},{"location":"fastapi/logging/#how-to-use-it","text":"To apply the interceptor, we recommend to add it into the base settings. Example: from loguru import logger from python_web_extras.fastapi.api_settings import APISettings from python_web_extras.fastapi.logging import InterceptHandler class Settings ( APISettings ): ... ... @lru_cache () def get_settings () -> Settings : settings = Settings () configure_logger ( settings ) return settings def configure_logger ( settings : Settings ) -> None : logging_level = logging . DEBUG if settings . debug else logging . INFO loggers = ( \"uvicorn.asgi\" , \"uvicorn.access\" ) logging . getLogger () . handlers = [ InterceptHandler ()] for logger_name in loggers : logging_logger = logging . getLogger ( logger_name ) logging_logger . handlers = [ InterceptHandler ( level = logging_level )] logger . configure ( handlers = [{ \"sink\" : sys . stderr , \"level\" : logging_level }]) From now on when the app starts with these settings, it will have the InterceptHandler embed and operational.","title":"How to use it"},{"location":"fastapi/logging/#working-example","text":"An example of this approach can be found here .","title":"Working example"},{"location":"fastapi/settings/","text":"Settings \u00b6 Python Web Extras comes full equipped with extras that can be added into any FastAPI application. Table of Contents \u00b6 Settings Table of Contents API Settings and Tortoise ORM How to use API Settings and Tortoise ORM \u00b6 The package is using FastAPI Utilities under the hood to simplify a lot of the process already built in and adds an extra flavour that allows the clean integration with Tortoise ORM . If you do not intend to use Tortoise ORM, this setting can be skipped or else it can be found here How to use \u00b6 In your settings you will need to import the current APISettings class. Example: # your_settings.py from python_web_extras.fastapi.api_settings import APISettings class Settings ( APISettings ): .... FastAPI Utilities recommends the use of a get_settings() using lru_cache() and this way it would be simpler to load your enviroment settings in different ways. A full example is available here .","title":"API Settings"},{"location":"fastapi/settings/#settings","text":"Python Web Extras comes full equipped with extras that can be added into any FastAPI application.","title":"Settings"},{"location":"fastapi/settings/#table-of-contents","text":"Settings Table of Contents API Settings and Tortoise ORM How to use","title":"Table of Contents"},{"location":"fastapi/settings/#api-settings-and-tortoise-orm","text":"The package is using FastAPI Utilities under the hood to simplify a lot of the process already built in and adds an extra flavour that allows the clean integration with Tortoise ORM . If you do not intend to use Tortoise ORM, this setting can be skipped or else it can be found here","title":"API Settings and Tortoise ORM"},{"location":"fastapi/settings/#how-to-use","text":"In your settings you will need to import the current APISettings class. Example: # your_settings.py from python_web_extras.fastapi.api_settings import APISettings class Settings ( APISettings ): .... FastAPI Utilities recommends the use of a get_settings() using lru_cache() and this way it would be simpler to load your enviroment settings in different ways. A full example is available here .","title":"How to use"},{"location":"fastapi/tortoise/hashers/","text":"Hashers \u00b6 Hashing passwords is the utmost important task when storing sensitive user information in the database. Table of Contents \u00b6 API Settings Defaults Custom Hashing Considerations API Settings \u00b6 In this section we mentioned the API Settings if using the integration with Tortoise ORM and this is the reason. Python Web Extras provides already some hashing algorightms as default for the passwords. Defaults \u00b6 # your_settings.py from python_web_extras.fastapi.api_settings import APISettings class Settings ( APISettings ): @property def fast_api_utils_password_hashers ( self ) -> list : return [ \"python_web_extras.contrib.auth.hashers.PBKDF2PasswordHasher\" , \"python_web_extras.contrib.auth.hashers.PBKDF2SHA1PasswordHasher\" , ] When using the User from the package, it will call the above settings and use these hashing modules to generate a secure password. Custom Hashing \u00b6 It is possible to add your custom hashing into the system as well. Example : hashers.py # hashers.py from python_web_extras.contrib.auth.hashers import PBKDF2PasswordHasher class MyCustomPBKDF2Hasher ( PBKDF2PasswordHasher ): iterations = 4000000 settings.py from python_web_extras.fastapi.api_settings import APISettings class Settings ( APISettings ): @property def fast_api_utils_password_hashers ( self ) -> list : return [ \"hashers.MyCustomPBKDF2Hasher\" , \"python_web_extras.contrib.auth.hashers.PBKDF2PasswordHasher\" , \"python_web_extras.contrib.auth.hashers.PBKDF2SHA1PasswordHasher\" , ] Considerations \u00b6 The package uses passlib for the hashing.","title":"Hashers"},{"location":"fastapi/tortoise/hashers/#hashers","text":"Hashing passwords is the utmost important task when storing sensitive user information in the database.","title":"Hashers"},{"location":"fastapi/tortoise/hashers/#table-of-contents","text":"API Settings Defaults Custom Hashing Considerations","title":"Table of Contents"},{"location":"fastapi/tortoise/hashers/#api-settings","text":"In this section we mentioned the API Settings if using the integration with Tortoise ORM and this is the reason. Python Web Extras provides already some hashing algorightms as default for the passwords.","title":"API Settings"},{"location":"fastapi/tortoise/hashers/#defaults","text":"# your_settings.py from python_web_extras.fastapi.api_settings import APISettings class Settings ( APISettings ): @property def fast_api_utils_password_hashers ( self ) -> list : return [ \"python_web_extras.contrib.auth.hashers.PBKDF2PasswordHasher\" , \"python_web_extras.contrib.auth.hashers.PBKDF2SHA1PasswordHasher\" , ] When using the User from the package, it will call the above settings and use these hashing modules to generate a secure password.","title":"Defaults"},{"location":"fastapi/tortoise/hashers/#custom-hashing","text":"It is possible to add your custom hashing into the system as well. Example : hashers.py # hashers.py from python_web_extras.contrib.auth.hashers import PBKDF2PasswordHasher class MyCustomPBKDF2Hasher ( PBKDF2PasswordHasher ): iterations = 4000000 settings.py from python_web_extras.fastapi.api_settings import APISettings class Settings ( APISettings ): @property def fast_api_utils_password_hashers ( self ) -> list : return [ \"hashers.MyCustomPBKDF2Hasher\" , \"python_web_extras.contrib.auth.hashers.PBKDF2PasswordHasher\" , \"python_web_extras.contrib.auth.hashers.PBKDF2SHA1PasswordHasher\" , ]","title":"Custom Hashing"},{"location":"fastapi/tortoise/hashers/#considerations","text":"The package uses passlib for the hashing.","title":"Considerations"},{"location":"fastapi/tortoise/models/","text":"Models \u00b6 This section is dedicated to Tortoise ORM integration with FastAPI and we advise to follow the installation of tortoise . Table of Contents \u00b6 Models Table of Contents Motivation User model How to use Defaults Available Models Working example Motivation \u00b6 Tortoise aims to simplify the integration of an ORM into any application in a very simple fashion and reducing the complexity of designing the models. Tortoise was based on Django ORM approach of declaring fields, tables and relationships between tables making the code simpler and cleaner. Unfortunately Tortoise does not offer, at least not yet, a whole experience of django when it comes to provide a User design approach and this is what we solve. One of the advantages of this ORM is the full use of async/await with the ORM. User model \u00b6 Django is great managing the users internally for their own purposes and middlewares. Majority of the applications do not need so many built-ins as it can be very opinionated. We simply provide a django user like model approach to save time and design for the applications that need to manage some users as well as provide some functionalities that allows the creation of a user and a superuser when needed as well as hashes the passwords when saving. How to use \u00b6 It's as simple has importing the models into the application. The Python Web Extras user model provides the following fields: id - IntegerField first_name - CharField last_name - CharField username - CharField email - CharField password - CharField last_login - DatetimeField is_active - BooleanField is_staff - BooleanField is_superuser - BooleanField Example: # models.py from python_web_extras.fastapi.models import User as AbstractUser class User ( AbstractUser ): class Meta : table = \"users\" # Table name in the database (internally) That is it! The migrations can be run as normal. Since this uses Tortoise ORM, we recommend their internal migration tool aerich . Defaults \u00b6 The AbstractUser model from the package inherits from the Model of Tortoise ORM and therefore adds the id automatically but that can be overriden by another default provided. Example: from python_web_extras.fastapi.models import User as AbstractUser from python_web_extras.fastapi.models import AutoIncrementBigIntMixin , AutoIncrementIntMixin class User ( AutoIncrementBigIntMixin , AbstractUser ): class Meta : table = \"users\" # Table name in the database (internally) class User ( AutoIncrementIntMixin , AbstractUser ): # Same as the default of the Model `id`. class Meta : table = \"users\" # Table name in the database (internally) Available Models \u00b6 AbstractUser - User table model. AutoIncrementBigIntMixin - Add a bigint id into the model. AutoIncrementIntMixin - Add an int id into the model. Working example \u00b6 An example of this approach can be found here","title":"Models"},{"location":"fastapi/tortoise/models/#models","text":"This section is dedicated to Tortoise ORM integration with FastAPI and we advise to follow the installation of tortoise .","title":"Models"},{"location":"fastapi/tortoise/models/#table-of-contents","text":"Models Table of Contents Motivation User model How to use Defaults Available Models Working example","title":"Table of Contents"},{"location":"fastapi/tortoise/models/#motivation","text":"Tortoise aims to simplify the integration of an ORM into any application in a very simple fashion and reducing the complexity of designing the models. Tortoise was based on Django ORM approach of declaring fields, tables and relationships between tables making the code simpler and cleaner. Unfortunately Tortoise does not offer, at least not yet, a whole experience of django when it comes to provide a User design approach and this is what we solve. One of the advantages of this ORM is the full use of async/await with the ORM.","title":"Motivation"},{"location":"fastapi/tortoise/models/#user-model","text":"Django is great managing the users internally for their own purposes and middlewares. Majority of the applications do not need so many built-ins as it can be very opinionated. We simply provide a django user like model approach to save time and design for the applications that need to manage some users as well as provide some functionalities that allows the creation of a user and a superuser when needed as well as hashes the passwords when saving.","title":"User model"},{"location":"fastapi/tortoise/models/#how-to-use","text":"It's as simple has importing the models into the application. The Python Web Extras user model provides the following fields: id - IntegerField first_name - CharField last_name - CharField username - CharField email - CharField password - CharField last_login - DatetimeField is_active - BooleanField is_staff - BooleanField is_superuser - BooleanField Example: # models.py from python_web_extras.fastapi.models import User as AbstractUser class User ( AbstractUser ): class Meta : table = \"users\" # Table name in the database (internally) That is it! The migrations can be run as normal. Since this uses Tortoise ORM, we recommend their internal migration tool aerich .","title":"How to use"},{"location":"fastapi/tortoise/models/#defaults","text":"The AbstractUser model from the package inherits from the Model of Tortoise ORM and therefore adds the id automatically but that can be overriden by another default provided. Example: from python_web_extras.fastapi.models import User as AbstractUser from python_web_extras.fastapi.models import AutoIncrementBigIntMixin , AutoIncrementIntMixin class User ( AutoIncrementBigIntMixin , AbstractUser ): class Meta : table = \"users\" # Table name in the database (internally) class User ( AutoIncrementIntMixin , AbstractUser ): # Same as the default of the Model `id`. class Meta : table = \"users\" # Table name in the database (internally)","title":"Defaults"},{"location":"fastapi/tortoise/models/#available-models","text":"AbstractUser - User table model. AutoIncrementBigIntMixin - Add a bigint id into the model. AutoIncrementIntMixin - Add an int id into the model.","title":"Available Models"},{"location":"fastapi/tortoise/models/#working-example","text":"An example of this approach can be found here","title":"Working example"}]}